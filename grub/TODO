-*- Mode: Outline -*-

Before working on anything in this file, it's very important that you
make contact with the core GRUB developers. Things herein might be
slightly out of date or otherwise not easy to understand at first
glance. So write to <bug-grub@gnu.org> first.

Priorities:
  Reported bugs generally have top priority.
  Non-reported and non-encountered bugs (things we know don't work,
    but don't really impede things) have lower priority.
  Things in this file are ranked with one to three !; the more, the
  higher priority.


* Port the script ``grub-install'' to FreeBSD, NetBSD and OpenBSD. At
  least you will have to modify the function `convert' so that it can
  translate a native device name into the corresponding GRUB drive
  representation.

* Add configuration inclusion support by adding a command "include".

* Make symbolic links work for BSD FFS.

* Add indirect block support to the BSD FFS filesystem code, so files
  larger than 16MB can be read.

* Fix-up FreeBSD, NetBSD (and OpenBSD ?) command-line boot
  parameters.

* Support embedding a Stage 1.5 in the "bootloader" area of a FFS
  partition.

* Support embedding a Stage 1.5 in the EXT2_BOOT_LOADER_INO of an ext2fs
  partition, so that it won't be accidentally erased or modified by
  the kernel.

* Complete the netboot support. !!!

  This is the proposed interface between the netboot module and the core
  system:

  - The module contains a header like this:

    struct netboot_module_header
    {
      /* The same as the Multiboot header, but has a different magic.  */
      struct multiboot_header mb_header;
      /* The version number to avoid incompatibilities.  */
      unsigned short compat_version;
      /* The identifier.  */
      unsigned short identifier;
      /* some pointers to callback functions.  */
      unsigned long init_func;
      unsigned long fini_func;
      unsigned long open_func;
      unsinged long read_func;
      unsinged long seek_func;
      unsinged long close_func;
      /* The address of the message buffer. The module should not print
         anything on the screen directly.  */
      unsinged long msg_addr;
      /* The maximum size of the message buffer (perhaps should be less
         than 80*24, because of the screen size).  */
      unsinged long msg_size;
    }

  - When the core system loads the module, check for the header
    structure and store the image in the specified memory address (in
    the ELF header or in MB_HEADER). If successful, call INIT_FUNC.

  - INIT_FUNC should initialize the module and return the required
    memory space. The prototype is:

    grub_error_t init_func (const struct multiboot_info *mbi,
                            unsigned long *mem_start,
                            unsigned long *mem_end);

    If the module does not need any extra memory space, then set
    *MEM_START to _START and *MEM_END to _END. MBI->CMDLINE has the
    command-line argument specified (probably netmask=... or something).

    FIXME: Should the module return most of the information dynamically
    from INIT_FUNC, instead of the module header?

  - When the core system unloads the module, call FINI_FUNC to restore
    the resources cleanly.

  - The prototype of FINI_FUNC is:

    grub_error_t fini_func (const struct multiboot_info *mbi);

  - The rest of the callback functions are equivalent to the filesystem
    callbacks. Their prototypes are:

    grub_error_t open_func (const struct multiboot_info *mbi,
                            const char *filename);
    grub_error_t read_func (const struct multiboot_info *mbi,
                            char *buffer, int len);
    grub_error_t seek_func (const struct multiboot_info *mbi,
                            int offset);
    grub_error_t close_func (const struct multiboot_info *mbi);

    FIXME: How to add decompression support?

  - The core system will print the string MSG_ADDR after each call is
    finished.

  - Each callback function will be run in the exactly same condition as
    when a Multiboot kernel starts up, and it MUST restore the condition
    before it returns (i.e. PIC or IDT).

* Add automatic configuration support.

* Add bunzip2 support.

* Define the module system.

* Add ISA PnP support.

* Fix the completion so that it works for BSD partitions as well. !

* Add BSD syntax support, using results of ioprobe to map drives. !
  (0x1f0-0x1f7 = primary IDE, 0x170-0x176 = secondary,
   0x1e8-0x1ef = tertiary, 0x168-0x16f = quaternary).

* Add more filesystems support (XFS, NTFS, etc.)

* Add remote console support (serial, parallel and net). !!

* Add RAID support.

? Add a partition naming syntax that means ``the first partition of
  this type''.  We need this for clean Hurd install floppies.

* Add a real scripting language, possibly retaining backward
  compatibility so that old config files can be used.

* Add internationalization support, emulating gettext as much as is
  feasible.

? Add command for modifying partition types.

* Add CDROM-chainloading support. It would be enough to support only
  BIOSes which have bootable-CDROM support (so you may use the "Bootable
  CDROM" BIOS calls). It is not trivial to support BIOSes without the
  capability to boot CDROM.
